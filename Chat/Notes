:Sockets.io
    :leverages the power of websockets along with several fallbacks, including JSON long polling and JSONP long polling
     through a single unified API.
    :It can be used to create bi-directional interactions such as real-time dashboards, chat app, multiplayer games
    :It is built with Engine.IO which is a lower-level abstraction on top of the websocket technology
    :It helps in triggering and listening to events between client-side and server-side
    :websocket API protocol is a TCP that relies on HTTP for its inital handshake.
    :It allows to use other real-time protocols if websockets aren't available.

:Polling
    :It is the process where currently running process waits for another process input.
    :It also refers to situations where it repeatedly checks for readiness state of another process
    :Implementation
        :Long/short polling (client pull) - client asking server for updates at certain regular intervals
            :Short polling is an AJAX-based timer that calls at fixed delays
                :AJAX calls work on the HTTP protocol meaning requests to the same domain should get multiplexed by
                 default
                :Pitfalls
                    :Multiplexing(Polling responses can't be in sync)
                    :Polling requires 3 round trips(TCP SIN, SSL, and Data)
                    :Timeouts(Connection getting closed by the proxy server if it remains idle for too long) 
            :Long polling is an comet
                :Comet - It is a model which is a long-held HTTPS request allows a web-server to push data to browser,
                         without the browser explicitly requesting it
        :Websockets(server push) - server is proactively pushing updates to the client
            :It will persists connection between client and the server.
            :Its a communication protocol providing full-duplex communications channel over a single TCP connection
            :Implementing custom mulitplexing on both server and client is bit complicated
            :They are frame-based not stream-based
            :Send messages to the server and get event-driven responses without having to poll the server for a reply
            :Websocket server:
                :A websocket server is an application listening on any port of a TCP server
                :Websocket handshake
                    :the server must listen for incoming socket connections using
            :Websocket client:
                :A client has to start the websocket handshake process by contacting the server and requesting 
                 a websocket connection
            :Data-frame going from client to server and vice-versa is masked using XOR encryption
            :Heartbeat or Control-frame of websockets are ping and pong can be used to determine the state of the connection
            :To close a connection either the client or server can send a control frame with data containing a specified
             control sequence to begin the closing handshake. Upon receiving such a frame, the other peers sends a close frame
             in response. The first peer then closes the connection. Any further data received after closing the connection is 
             then discarded
            :Websockets is not necessarily a good protocol if neither of the endpoints is an actual browser
            :It suffers a lot under restrictions and implementation details that were forced upon the protocol to make it
             work with existing HTTP infrastructure
            :In practice it combines parts of UDP (message based) and TCP for reliability
            :To use websockets an upgrade from HTTP connection to TCP connection is imminent
                :Why ?
                    :A server that handles stateless requests to answer with a reply has a very different behaviour
                     than a server that keeps a TCP connections open.
                    :It uses privileged ports which is used by HTTP/HTTPS
        :Server-Sent Events(server push)
            :Its a mechanism that allows the server to asynchronously push the data to the client once the client-
             server connection is established
            :It follows publish-subscribe model
            :SSE is based on HTTP, it has a natural fit with HTTP/2  
:Implementation
    :socket.on('listeners', ()) - listens to the event
    :socket.emit('emitters', ()) - emit an event to the socket

:TCP
    :TCP can be used establish a connection and exchange data between applications in an communication network
    :A three-way handshake is required to open a connection hence, it is called as connection-oriented protocol
    :TCP prevents the sender from sending in more data than receiver can handle with the window size provided by the receiver
    :Each packet(segment) would have a checksum field for error control
    :It guarantees the reliable delivery of segments. Incase of segment loss or corruption, segments are re-transmitted
    :It resassembles the packet in the correct order at the receiver side
    :It uses a congestion avoidance algorithm to avoid the network from being congested